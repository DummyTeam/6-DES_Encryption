string BCH(string hexadec)
string decToBin(ull dec)
string strToBin(string mes, bool isSpaced, bool withInitialPaddind)

0123456789ABCDEF

0 - 0000
1 - 0001
...
...
...
9 - 1001
A - 1010
B - 1011
C - 1100
D - 1101
E - 1110
F - 1111

- We have a message (string text)
- We have a key (string text)
- Convert message and key to binary (string binary) using unicode

Key generation (we need 16 keys)
- Run the binary key through PC-1 table (From 64 to 56 bit)
- Split the resulting 56bit key into 2 parts C and D
- This keys should be shifted to left 1 or 2 bits 16 times to generate other
  keys. Number of left shifts is determined with fixed table.
- After getting 16 pairs of C and D sets, concatenate them
- Run the resulting keys through PC-2
//We have 16 keys for each round.

Encyription algorithm
- Split binary message to 64 bit chunks
- Run 64 bit data through IP (initial permutation)
- Divide message into to parts: L(left) and R(right)
- Run these formulas for 16 rounds
		L(n) = R(n-1);
		R(n) = L(n-1) + f(R(n-1), K(n));
	- f function first expanpandes R from 32 bit to 48 bit (run through E selection table)
	- f function then apply XOR operation: (R(n-1)^K(n))
	- f function then runs the result (8 times 6 bits = 48 bit) through 8 S boxes
		S box is type of table. First and last bits help to find row 
		and middle 4 bits help to find column. Table gives 4 bit data.
	- f function, finally, passes the 32 bit result through a Permutation Function

- After finding L(16) and R(16), order should be reversed and concatenated like this:
	R(16)L(16)
- Concatinated string should be passed through final permutation IP(-1) table